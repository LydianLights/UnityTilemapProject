using System.Collections;
using System.Collections.Generic;
using UnityEngine;


[RequireComponent (typeof(MeshFilter))]
[RequireComponent (typeof(MeshRenderer))]
[RequireComponent (typeof(MeshCollider))]
[RequireComponent (typeof(TileMap))]
public class TileMapMeshBuilder : MonoBehaviour
{
	// The tilemap to build the mesh for
	TileMap map;

	// Tileset to load tiles from
	[SerializeField] TileSet tileSet;

	// Object mesh components
	MeshFilter meshFilter;
	MeshRenderer meshRenderer;
	MeshCollider meshCollider;

	// Unity scale of the tilemap
	[SerializeField] float tileScale = 1.0f;
	public float TileScale {get { return tileScale; } private set { tileScale = value; } }


	void Awake()
	{
		// Get reference to game object components
		meshFilter = GetComponent<MeshFilter>();
		meshRenderer = GetComponent<MeshRenderer>();
		meshCollider = GetComponent<MeshCollider>();
		map = GetComponent<TileMap>();
	}

	void Start()
	{
		// Build mesh and texture it
		BuildMesh();
	}


	// Generates mesh data for the tilemap
	// Mesh built such that each tile = one square in the mesh
	// TODO: Re-evalutate mesh construction -- try one quad per tile for efficient mapping of tile texture
	void BuildMesh()
	{
		int numVertices = 4 * map.NumTiles;
		int numTriangles = 2 * map.NumTiles;

		// Initialize arrays for mesh data
		Vector3[] vertices = new Vector3[numVertices];
		int[] triangles = new int[numTriangles * 3];
		Vector3[] normals = new Vector3[numVertices];
		Vector2[] uv = new Vector2[numVertices];

		// Iterate through each tile and set verticies/triangles
		for(int i = 0; i < map.NumTiles; i++)
		{
			int vertOffset = 4 * i;
			int triOffset = 2 * i;
			int xOffset = i % map.TilesWide;
			int zOffset =  i / map.TilesWide;


			// Set vertex coords of current tile
			vertices[vertOffset + 0] = new Vector3(xOffset * TileScale, 0, zOffset * TileScale);
			vertices[vertOffset + 1] = new Vector3((xOffset + 1) * TileScale, 0, 0);
			vertices[vertOffset + 2] = new Vector3(0, 0, (zOffset + 1) * TileScale);
			vertices[vertOffset + 3] = new Vector3((xOffset + 1) * TileScale, 0, (zOffset + 1) * TileScale);


		}

		/*
		// DEBUG: Hardcoded for testing
		int dbg_offset = 2;
		vertices[0] = new Vector3(0, 0, 0);
		vertices[1] = new Vector3(1, 0, 0);
		vertices[2] = new Vector3(0, 0, 1);
		vertices[3] = new Vector3(1, 0, 1);

		vertices[4] = new Vector3(0 + dbg_offset, 0, 0);
		vertices[5] = new Vector3(1 + dbg_offset, 0, 0);
		vertices[6] = new Vector3(0 + dbg_offset, 0, 1);
		vertices[7] = new Vector3(1 + dbg_offset, 0, 1);
		*/


		// DEBUG: Hardcoded for testing
		triangles[0] = 0;
		triangles[1] = 2;
		triangles[2] = 1;

		triangles[3] = 1;
		triangles[4] = 2;
		triangles[5] = 3;

		triangles[6] = 4;
		triangles[7] = 6;
		triangles[8] = 5;

		triangles[9] = 5;
		triangles[10] = 6;
		triangles[11] = 7;


		// DEBUG: Hardcoded for testing
		uv[0] = new Vector2(0, 0);
		uv[1] = new Vector2((float)tileSet.TileResolution / tileSet.Texture.width, 0);
		uv[2] = new Vector2(0, (float)tileSet.TileResolution / tileSet.Texture.height);
		uv[3] = new Vector2((float)tileSet.TileResolution / tileSet.Texture.width, (float)tileSet.TileResolution / tileSet.Texture.height);

		uv[4] = new Vector2((float)tileSet.TileResolution / tileSet.Texture.width, (float)tileSet.TileResolution / tileSet.Texture.height);
		uv[5] = new Vector2(2 * (float)tileSet.TileResolution / tileSet.Texture.width, (float)tileSet.TileResolution / tileSet.Texture.height);
		uv[6] = new Vector2((float)tileSet.TileResolution / tileSet.Texture.width, 2 * (float)tileSet.TileResolution / tileSet.Texture.height);
		uv[7] = new Vector2(2 * (float)tileSet.TileResolution / tileSet.Texture.width, 2 * (float)tileSet.TileResolution / tileSet.Texture.height);


		for (int i = 0; i < numVertices; i++)
		{
			normals[i] = Vector3.up;
		}










		// Create new mesh and populate with mesh data
		Mesh mesh = new Mesh();
		mesh.vertices = vertices;
		mesh.triangles = triangles;
		mesh.normals = normals;
		mesh.uv = uv;



		meshFilter.mesh = mesh;
		meshRenderer.sharedMaterial.mainTexture = tileSet.Texture;
	}


	// Public functions for inspector mode
	#if UNITY_EDITOR
	public void InspectorRefreshAwake()
	{
		Awake();
		tileSet.InspectorRefreshAwake();
		map.InspectorRefreshAwake();
	}

	public void InspectorRefreshStart()
	{
		Start();
		tileSet.InspectorRefreshStart();
		map.InspectorRefreshStart();
	}
	#endif
}